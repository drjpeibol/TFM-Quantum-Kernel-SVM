%--------------------------------------------------------------------------%  Sample_generation_2qubit_v1_1 : program to check the data generation explaind in%                         the paper J.R. Click "Covariant quantum kernels %                         for data with group structure" 2022%--------------------------------------------------------------------------function Sample_generation_2qubit_v1_2%Symbolic calculationssymbolic = 0;  %Use 1 to get the body of the U functionsamples = 1; % Number of samples to generateeps = 0.02; %Variance of the random error applyed% Identity I = [ 1 0       0 1 ];% Pauli MatricesX = [ 0 1      1 0 ];Y = [ 0  -1i      1i   0];Z = [  1  0        0 -1 ];%-------------------------------------------------------------------------% Matrix expresion calculation for the U function X-Z-X following Nielsen % "Quantum Computation and Quantum Information" page 174if symbolic == 1    syms delta_angle    Rot0 = [ exp(1i*delta_angle)    0           0              exp(1i*delta_angle) ];    syms theta_1    Rot1 = [ cos(theta_1/2)    -1i*sin(theta_1/2);            -1i*sin(theta_1/2)    cos(theta_1/2)  ];    syms theta_2    Rot2 = [ exp(-1i*theta_2/2)    0            0              exp(1i*theta_2/2) ];        syms theta_3    Rot3 = [ cos(theta_3/2)    -1i*sin(theta_3/2);            -1i*sin(theta_3/2)    cos(theta_3/2)  ];    Result = Rot0*Rot1*Rot2*Rot3;    fprintf ('U(2) as Euler angles decomposition:\n');    fprintf("M(1,1) = %s; \nM(1,2)= %s;\nM(2,1) = %s;\nM(2,2) = %s;\n",Result(1,1), ...                Result(1,2), Result(2,1), Result(2,2)); %Copy in U fucntionend                   % Random rotations generation for test delta = random('uniform', -pi/2, pi/2);theta_1= random('uniform', -pi/2, pi/2);theta_2 = random('uniform', -pi/2, pi/2);theta_3 = random('uniform', -pi/2, pi/2);% These two calls should be equivalent A = U(delta, theta_1, theta_2, theta_3);B = D([-2*delta theta_1 theta_2 theta_3], I, X, Z, X);Diff_matrix = A - B;if norm (Diff_matrix) >= 0.001     fprintf('Different calculations\n');else  fprintf ('SU(2) Matrix generations test OK\n');end% Symbolic generation of% kron( D(theta_1, theta_2,0 ), D(theta_3, theta_4,0))    if symbolic == 1    syms theta_1    Rot1 = [ cos(theta_1/2)    -1i*sin(theta_1/2);            -1i*sin(theta_1/2)    cos(theta_1/2)  ];    syms theta_2    Rot2 = [ exp(-1i*theta_2/2)    0            0              exp(1i*theta_2/2) ];     syms theta_3    Rot3 = [ cos(theta_3/2)    -1i*sin(theta_3/2);            -1i*sin(theta_3/2)    cos(theta_3/2)  ];    syms theta_4    Rot4 = [ exp(-1i*theta_4/2)    0            0              exp(1i*theta_4/2) ];    Result = kron(Rot1*Rot2, Rot3*Rot4);    fprintf ('Tensor product decompositon:\n');    fprintf("M(1,1) = %s; \nM(1,2)= %s;\nM(1,3) = %s;\nM(1,4) = %s;\n",....             Result(1,1), Result(1,2), Result(1,3), Result(1,4));     fprintf("M(2,1) = %s; \nM(2,2)= %s;\nM(2,3) = %s;\nM(2,4) = %s;\n",....             Result(2,1), Result(2,2), Result(2,3), Result(2,4));    fprintf("M(3,1) = %s; \nM(3,2)= %s;\nM(3,3) = %s;\nM(3,4) = %s;\n",....             Result(3,1), Result(3,2), Result(3,3), Result(3,4));     fprintf("M(4,1) = %s; \nM(4,2)= %s;\nM(4,3) = %s;\nM(4,4) = %s;\n",....             Result(4,1), Result(4,2), Result(4,3), Result(4,4));                         end%-------------------------------------------------------------------------% % Reverse calculations -> testing the functions% for j = 1:test_number%     delta = 0.0; %random('uniform', -pi/2, pi/2);%     theta_1 = random('uniform', -pi/2, pi/2);%     theta_2 = random('uniform', -pi/2, pi/2);%     theta_3 = 0.0;   %random('uniform', -pi/2, pi/2);%     %  %     A = U(0.0, theta_1, theta_2, 0.0);%     estimated_angles = Matrix_angles(A);%     %     % delta should be zero anyway no need to scalate -2*delta %     B = D(estimated_angles, I, X, Z, X);%     %     if norm(A-B) <= 0.001 %         %fprintf('Matrix generated with estimated angles OK\n');%     else%         fprintf('Different Matrix generated with estimated angles\n');%         fprintf ('\nRandom    delta : %4.4f, theta_1 : %4.4f, theta_2 :  %4.4f, theta_3:  %4.4f\n', ...%                                 delta, theta_1, theta_2, theta_3); %         fprintf ('\nEstimated delta : : %4.4f, theta_1 : %4.4f, theta_2 :  %4.4f, theta_3:  %4.4f\n', ...%                    estimated_angles(1), estimated_angles(2), ...%                    estimated_angles(3), estimated_angles(4));%     end%     %     % end%--------------------------------------------------------------------% %  Testing two qbits% for k = 1:test_number%     theta_1 = random('uniform', -pi/2, pi/2);%     theta_2 = random('uniform', -pi/2, pi/2);%     theta_3 = random('uniform', -pi/2, pi/2);%     theta_4 = random('uniform', -pi/2, pi/2);%     theta = [theta_1, theta_2, theta_3, theta_4];%     %     %     % c_minus generation%     c_minus = kron (D([0 theta_1 theta_2 0],I, X, Z, X),...%                     D([0 theta_3 theta_4 0],I, X, Z, X));%     A = DxD(theta_1, theta_2, theta_3, theta_4);%     %     % test matrix generation%     if norm(c_minus -A) <= 0.001%         %fprintf('DxD different generations\n');%     end%   %     % Euler angles decomposition%     estimated_angles = DxD_Euler_angles (c_minus);%     %     %test%     if norm(theta-estimated_angles) <= 0.001%         fprintf ('\nRandom    theta_1 : %4.4f, theta_2 :  %4.4f, theta_3:  %4.4f, theta_4:  %4.4f\n', ...%                                 theta_1, theta_2, theta_3, theta_4); %         fprintf ('\nEstimated theta_1 : %4.4f, theta_2 :  %4.4f, theta_3:  %4.4f, theta_4:  %4.4f\n', ...%                   estimated_angles(1), estimated_angles(2), estimated_angles(3), ...%                   estimated_angles(4));%     end% end%Sample generations_1 = kron (X,Z)  % Stabilizer group member S = {I,X1Z2} X1Z2*X1Z2 = Is_2 = kron(I,I)    theta_1_ = pi/2;    theta_2_ = pi/2;    theta_3_ = pi/2;    theta_4_ = pi/2;    c_minus = DxD(theta_1_, theta_2_, theta_3_, theta_4_);    theta_1 = random('uniform', -pi/2, pi/2);    theta_2 = random('uniform', -pi/2, pi/2);    theta_3 = random('uniform', -pi/2, pi/2);    theta_4 = random('uniform', -pi/2, pi/2);    c_plus = DxD(theta_1, theta_2, theta_3, theta_4);        % Generate sample    sample_minus = c_minus*s_1;    sample_plus = c_plus*s_1;         % Express it as Euler angles as SU(4) matrix    sample_angles_ = DxD_Euler_angles (sample_minus);    sample_angles = DxD_Euler_angles (sample_plus);    %test    A=DxD(sample_angles_(1),sample_angles_(2),sample_angles_(3),sample_angles_(4));    B=DxD(sample_angles(1),sample_angles(2),sample_angles(3),sample_angles(4));    if (norm(A-sample_minus)) <= 0.001%         fprintf('Euler decomposition warning\n');%         fprintf ('\nRandom    theta_1 : %4.4f, theta_2 :  %4.4f, theta_3:  %4.4f, theta_4:  %4.4f\n', ...%                                 theta_1, theta_2, theta_3, theta_4); %         fprintf ('\nEstimated theta_1 : %4.4f, theta_2 :  %4.4f, theta_3:  %4.4f, theta_4:  %4.4f\n', ...%                   sample_angles(1), sample_angles(2), sample_angles(3), ...%                   sample_angles(4));%c_minus*s_1        writematrix ([sample_angles_,-1,1],'C1.csv','WriteMode','overwrite');%c_minus*I        writematrix ([theta_1_, theta_2_, theta_3_, theta_4_,-1,0],'C1.csv','WriteMode','append');    end    if (norm(B-sample_plus)) <= 0.001%         fprintf('Euler decomposition warning\n');%         fprintf ('\nRandom    theta_1 : %4.4f, theta_2 :  %4.4f, theta_3:  %4.4f, theta_4:  %4.4f\n', ...%                                 theta_1, theta_2, theta_3, theta_4); %         fprintf ('\nEstimated theta_1 : %4.4f, theta_2 :  %4.4f, theta_3:  %4.4f, theta_4:  %4.4f\n', ...%                   sample_angles(1), sample_angles(2), sample_angles(3), ...%                   sample_angles(4));%c_plus*s_1        writematrix ([sample_angles,1,1],'C1.csv','WriteMode','append');%c_plus*I        writematrix ([theta_1, theta_2, theta_3, theta_4,1,0],'C1.csv','WriteMode','append');    end    for i = 1:samples%c_minus*s_1        writematrix ([[sample_angles_(1),sample_angles_(2),sample_angles_(3),sample_angles_(4)]+ [sample_angles_(1)*random("Normal",0,sqrt(eps)),sample_angles_(2)*random("Normal",0,sqrt(eps)),sample_angles_(3)*random("Normal",0,sqrt(eps)),sample_angles_(4)*random("Normal",0,sqrt(eps))],-1,1],'C1.csv','WriteMode','append');%c_minus*I        writematrix ([[theta_1_, theta_2_, theta_3_, theta_4_] + [theta_1_*random("Normal",0,sqrt(eps)), theta_2_*random("Normal",0,sqrt(eps)), theta_3_*random("Normal",0,sqrt(eps)), theta_4_*random("Normal",0,sqrt(eps))],-1,0],'C1.csv','WriteMode','append');%c_plus*s_1        writematrix ([[sample_angles(1),sample_angles(2),sample_angles(3),sample_angles(4)]+ [sample_angles(1)*random("Normal",0,sqrt(eps)),sample_angles(2)*random("Normal",0,sqrt(eps)),sample_angles(3)*random("Normal",0,sqrt(eps)),sample_angles(4)*random("Normal",0,sqrt(eps))],1,1],'C1.csv','WriteMode','append');%c_plus*I        writematrix ([[theta_1, theta_2, theta_3, theta_4 ]+ [theta_1*random("Normal",0,sqrt(eps)), theta_2*random("Normal",0,sqrt(eps)), theta_3*random("Normal",0,sqrt(eps)), theta_4*random("Normal",0,sqrt(eps))],1,0],'C1.csv','WriteMode','append');     end    end%----------------------------------------------------------------% DxD : Generates tensor product of two D SU(2) matrices%------------------------------------------------------------function M = DxD(theta_1, theta_2, theta_3, theta_4)M(1,1) = cos(theta_1/2)*cos(theta_3/2)*exp(-(theta_2*1i)/2)*exp(-(theta_4*1i)/2); M(1,2)= -cos(theta_1/2)*sin(theta_3/2)*exp(-(theta_2*1i)/2)*exp((theta_4*1i)/2)*1i;M(1,3) = -cos(theta_3/2)*sin(theta_1/2)*exp((theta_2*1i)/2)*exp(-(theta_4*1i)/2)*1i;M(1,4) = -sin(theta_1/2)*sin(theta_3/2)*exp((theta_2*1i)/2)*exp((theta_4*1i)/2);M(2,1) = -cos(theta_1/2)*sin(theta_3/2)*exp(-(theta_2*1i)/2)*exp(-(theta_4*1i)/2)*1i; M(2,2)= cos(theta_1/2)*cos(theta_3/2)*exp(-(theta_2*1i)/2)*exp((theta_4*1i)/2);M(2,3) = -sin(theta_1/2)*sin(theta_3/2)*exp((theta_2*1i)/2)*exp(-(theta_4*1i)/2);M(2,4) = -cos(theta_3/2)*sin(theta_1/2)*exp((theta_2*1i)/2)*exp((theta_4*1i)/2)*1i;M(3,1) = -cos(theta_3/2)*sin(theta_1/2)*exp(-(theta_2*1i)/2)*exp(-(theta_4*1i)/2)*1i; M(3,2)= -sin(theta_1/2)*sin(theta_3/2)*exp(-(theta_2*1i)/2)*exp((theta_4*1i)/2);M(3,3) = cos(theta_1/2)*cos(theta_3/2)*exp((theta_2*1i)/2)*exp(-(theta_4*1i)/2);M(3,4) = -cos(theta_1/2)*sin(theta_3/2)*exp((theta_2*1i)/2)*exp((theta_4*1i)/2)*1i;M(4,1) = -sin(theta_1/2)*sin(theta_3/2)*exp(-(theta_2*1i)/2)*exp(-(theta_4*1i)/2); M(4,2)= -cos(theta_3/2)*sin(theta_1/2)*exp(-(theta_2*1i)/2)*exp((theta_4*1i)/2)*1i;M(4,3) = -cos(theta_1/2)*sin(theta_3/2)*exp((theta_2*1i)/2)*exp(-(theta_4*1i)/2)*1i;M(4,4) = cos(theta_1/2)*cos(theta_3/2)*exp((theta_2*1i)/2)*exp((theta_4*1i)/2);end%------------------------------------------------------------------------% DxD_Euler_angles : Caluclates the Euler angles for a SU(4) = DxD matitx%------------------------------------------------------------------------function angles = DxD_Euler_angles (M)%M is SU(4)I= [ 1 0 0 0      0 1 0 0      0 0 1 0      0 0 0 1 ]; if norm(M*M'-I) >= 0.001    % not U4     angles=[0 0 0 0];     return elseif det(M)-1 >= 0.001  % not SU(4)     angles = [0 0 0 0];     return end         % Using M explicit expressions % M(1,2)= -cos(theta_1/2)*sin(theta_3/2)*exp(-(theta_2*1i)/2)*exp((theta_4*1i)/2)*1i;% M(1,1) = cos(theta_1/2)*cos(theta_3/2)*exp(-(theta_2*1i)/2)*exp(-(theta_4*1i)/2); theta_3 =   2*atan( abs(M(1,2)/M(1,1)) );% M(1,4) = -sin(theta_1/2)*sin(theta_3/2)*exp((theta_2*1i)/2)*exp((theta_4*1i)/2);% M(2,1) = -cos(theta_1/2)*sin(theta_3/2)*exp(-(theta_2*1i)/2)*exp(-(theta_4*1i)/2)*1i; theta_1 =   2*atan( abs(M(1,4)/M(2,1)) );% M(2,2)= cos(theta_1/2)*cos(theta_3/2)*exp(-(theta_2*1i)/2)*exp((theta_4*1i)/2);% M(1,1) = cos(theta_1/2)*cos(theta_3/2)*exp(-(theta_2*1i)/2)*exp(-(theta_4*1i)/2);theta_4 =  angle(M(2,2)) - angle (M (1,1));% M(1,4) = -sin(theta_1/2)*sin(theta_3/2)*exp((theta_2*1i)/2)*exp((theta_4*1i)/2);% M(2,3) = -sin(theta_1/2)*sin(theta_3/2)*exp((theta_2*1i)/2)*exp(-(theta_4*1i)/2);theta_2 = angle(M(1,4)) + angle(M(2,3));%Angle correction to [-pi/2, pi/2]if theta_2 >= 3*pi/4    theta_2 = 2*pi - theta_2;endif theta_2 <= -3*pi/4    theta_2 = 2*pi + theta_2;end% Angle correction to [-pi/2,pi/2]% M(1,2)= -cos(theta_1/2)*sin(theta_3/2)*exp(-(theta_2*1i)/2)*exp((theta_4*1i)/2)*1i;if  M(1,2)/(exp(-(theta_2*1i)/2)*exp((theta_4*1i)/2)*1i) >= 0.0    if theta_3 >= 0.0       theta_3 = -theta_3;    endend% Angle correction to [-pi/2,pi/2]% M(1,3) = -cos(theta_3/2)*sin(theta_1/2)*exp((theta_2*1i)/2)*exp(-(theta_4*1i)/2)*1i;if M(1,3)/( exp((theta_2*1i)/2)*exp(-(theta_4*1i)/2)*1i ) >= 0.0    if theta_1 >= 0.0       theta_1 = -theta_1;    endend    % M(1,1) = cos(theta_1/2)*cos(theta_3/2)*exp(-(theta_2*1i)/2)*exp(-(theta_4*1i)/2); if abs(M(1,1) - cos(theta_1/2)*cos(theta_3/2)*exp(-(theta_2*1i)/2)*exp(-(theta_4*1i)/2)) >= 0.001    theta_2 = -theta_2;end%Return resultsangles = [theta_1 theta_2 theta_3 theta_4 ];end%-------------------------------------------------------------------------% Matrix_angles : given a unitary  matrix, calculates the %                 angles which parametrise it. We impose theta_3 = 0%------------------------------------------------------------------------function angles = Matrix_angles (M)I=[1 0     0 1];% M matrix should be SU(2)->  M*M' = I% M' is the Hermitian adjoint (traspose and conjugate)   if norm(M*M'-I) >= 0.001  % Not Unitary       angles = [0 0 0 0];   else       % delta angle from the determinant        delta = angle (det(M))/2;             %remove phase from matrix       M = expm(-1i*delta)*M;              % Calculate alpha, theta and beta       a = M(1,1);  b = M(1,2);       c = M(2,1);  d = M(2,2);%        M(1,1) = cos(theta_1/2)*exp(-(theta_2*1i)/2); %        M(1,2)= -sin(theta_1/2)*exp((theta_2*1i)/2)*1i;%        M(2,1) = -sin(theta_1/2)*exp(-(theta_2*1i)/2)*1i;%        M(2,2) = cos(theta_1/2)*exp((theta_2*1i)/2);                     if (abs(a) >= 0.0001)           theta_1 = 2*acos(abs(a));       else           theta_1 = 2*asin(abs(b));       end       theta_2 = 2*angle(d);              if b/exp((theta_2*1i)/2)*1i <=  0.0           theta_1 = -theta_1;       end              angles = [ delta theta_1 theta_2 0];                     endend%--------------------------------------------------------------------------% U: returns the matrix generated with the angles delta, theta_1, theta_2,%    theta_3, theta_4%--------------------------------------------------------------------------function M = U(delta_angle, theta_1, theta_2, theta_3)M = [0 0    0 0];M(1,1) = cos(theta_1/2)*cos(theta_3/2)*exp(delta_angle*1i)*exp(-(theta_2*1i)/2) - sin(theta_1/2)*sin(theta_3/2)*exp(delta_angle*1i)*exp((theta_2*1i)/2); M(1,2)= - cos(theta_1/2)*sin(theta_3/2)*exp(delta_angle*1i)*exp(-(theta_2*1i)/2)*1i - cos(theta_3/2)*sin(theta_1/2)*exp(delta_angle*1i)*exp((theta_2*1i)/2)*1i;M(2,1) = - cos(theta_1/2)*sin(theta_3/2)*exp(delta_angle*1i)*exp((theta_2*1i)/2)*1i - cos(theta_3/2)*sin(theta_1/2)*exp(delta_angle*1i)*exp(-(theta_2*1i)/2)*1i;M(2,2) = cos(theta_1/2)*cos(theta_3/2)*exp(delta_angle*1i)*exp((theta_2*1i)/2) - sin(theta_1/2)*sin(theta_3/2)*exp(delta_angle*1i)*exp(-(theta_2*1i)/2);end%-------------------------------------------------------------------------%  D : returns the product of the exponentials of the three square matrices%      A1, A2, A3 and A4  as  D = exp(-ia1A1/2)*exp(-ia2A2/2)*exp(-ia3A3/2)%      *exp(-ia4A4/2)%-------------------------------------------------------------------------function M = D (angles, A1, A2, A3, A4)    % Use of matrix exponentials     M =  expm(-1i*angles(1)*A1/2)...        *expm(-1i*angles(2)*A2/2)...        *expm(-1i*angles(3)*A3/2)...        *expm(-1i*angles(4)*A4/2);end